{"version":3,"file":"urql-exchange-execute.js","sources":["../src/execute.ts"],"sourcesContent":["import {\n  Source,\n  pipe,\n  share,\n  filter,\n  takeUntil,\n  mergeMap,\n  merge,\n  make,\n} from 'wonka';\n\nimport {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  GraphQLTypeResolver,\n  execute,\n  subscribe,\n  ExecutionArgs,\n  SubscriptionArgs,\n} from 'graphql';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  makeResult,\n  makeErrorResult,\n  mergeResultPatch,\n  Operation,\n  OperationResult,\n  getOperationName,\n} from '@urql/core';\n\nexport interface ExecuteExchangeArgs {\n  schema: GraphQLSchema;\n  rootValue?: any;\n  context?: ((op: Operation) => any) | any;\n  fieldResolver?: GraphQLFieldResolver<any, any>;\n  typeResolver?: GraphQLTypeResolver<any, any>;\n  subscribeFieldResolver?: GraphQLFieldResolver<any, any>;\n}\n\ntype ExecuteParams = ExecutionArgs | SubscriptionArgs;\n\nconst asyncIterator =\n  typeof Symbol !== 'undefined' ? Symbol.asyncIterator : null;\n\nconst makeExecuteSource = (\n  operation: Operation,\n  _args: ExecuteParams\n): Source<OperationResult> => {\n  return make<OperationResult>(observer => {\n    let iterator: AsyncIterator<ExecutionResult>;\n    let ended = false;\n\n    Promise.resolve()\n      .then(async () => ({ ..._args, contextValue: await _args.contextValue }))\n      .then(args => {\n        if (ended) return;\n        if (operation.kind === 'subscription') {\n          return subscribe(args) as any;\n        }\n        return execute(args) as any;\n      })\n      .then((result: ExecutionResult | AsyncIterable<ExecutionResult>) => {\n        if (ended || !result) {\n          return;\n        } else if (!asyncIterator || !result[asyncIterator]) {\n          observer.next(makeResult(operation, result as ExecutionResult));\n          return;\n        }\n        iterator = result[asyncIterator!]();\n        let prevResult: OperationResult | null = null;\n\n        function next({\n          done,\n          value,\n        }: {\n          done?: boolean;\n          value: ExecutionResult;\n        }) {\n          if (value) {\n            observer.next(\n              (prevResult = prevResult\n                ? mergeResultPatch(prevResult, value)\n                : makeResult(operation, value))\n            );\n          }\n\n          if (!done && !ended) {\n            return iterator.next().then(next);\n          }\n        }\n\n        return iterator.next().then(next);\n      })\n      .then(() => {\n        observer.complete();\n      })\n      .catch(error => {\n        observer.next(makeErrorResult(operation, error));\n        observer.complete();\n      });\n\n    return () => {\n      if (iterator && iterator.return) iterator.return();\n      ended = true;\n    };\n  });\n};\n\n/** Exchange for executing queries locally on a schema using graphql-js. */\nexport const executeExchange = ({\n  schema,\n  rootValue,\n  context,\n  fieldResolver,\n  typeResolver,\n  subscribeFieldResolver,\n}: ExecuteExchangeArgs): Exchange => ({ forward }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const executedOps$ = pipe(\n      sharedOps$,\n      filter((operation: Operation) => {\n        return (\n          operation.kind === 'query' ||\n          operation.kind === 'mutation' ||\n          operation.kind === 'subscription'\n        );\n      }),\n      mergeMap((operation: Operation) => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const contextValue =\n          typeof context === 'function' ? context(operation) : context;\n\n        // Filter undefined values from variables before calling execute()\n        // to support default values within directives.\n        const variableValues = Object.create(null);\n        if (operation.variables) {\n          for (const key in operation.variables) {\n            if (operation.variables[key] !== undefined) {\n              variableValues[key] = operation.variables[key];\n            }\n          }\n        }\n\n        return pipe(\n          makeExecuteSource(operation, {\n            schema,\n            document: operation.query,\n            rootValue,\n            contextValue,\n            variableValues,\n            operationName: getOperationName(operation.query),\n            fieldResolver,\n            typeResolver,\n            subscribeFieldResolver,\n          }),\n          takeUntil(teardown$)\n        );\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      sharedOps$,\n      filter(operation => operation.kind === 'teardown'),\n      forward\n    );\n\n    return merge([executedOps$, forwardedOps$]);\n  };\n};\n"],"names":["asyncIterator","Symbol","makeExecuteSource","operation","_args","make","observer","iterator","then","contextValue","ended","kind","subscribe","args","execute","result","next","done","value","prevResult","mergeResultPatch","return","executeExchange","schema","rootValue","context","fieldResolver","typeResolver","subscribeFieldResolver","forward","sharedOps$","share","ops$","mergeMap","key","variables","takeUntil","teardown$","operationName","getOperationName","query"],"mappings":";;;;;;AA2CA,IAAAA,aAAA,GAAA,OAAAC,MAAA,KAAA,WAAA,GAAAA,MAAA,CAAAD,aAAA,GAAA,IAAA,CAAA;;AAGA,IAAAE,iBAAA,GAAA,CAAAC,SAAA,EAAAC,KAAA,KAAA;EAIE,OAAAC,UAAA,CAAAC,QAAA,IAAA;AACE,IAAA,IAAAC,QAAA,CAAA;;qBAIGC,CAAAA,KAAA,aAAA,EAAA,GAAAJ,KAAA;MAAAK,YAAA,EAAA,MAAAL,KAAA,CAAAK,YAAAA;AAAA,KAAA;AAEC,MAAA,IAAAC,KAAA;;AACA,MAAA,IAAAP,SAAA,CAAAQ,IAAA,KAAA,cAAA,EAAA;QACE,OAAAC,iBAAA,CAAAC,IAAA,CAAA,CAAA;AACD,OAAA;;MACD,OAAAC,eAAA,CAAAD,IAAA,CAAA,CAAA;AACF,MACCL,CAAAA,KAAAO,MAAA,IAAA;AACC,MAAA,IAAAL,KAAA,IAAA,CAAAK,MAAA,EAAA;;OAAA;;;AAKC,OAAA;;AACDR,MAAAA,QAAA,GAAAQ,MAAA,CAAAf,aAAA,CAAA,EAAA,CAAA;;;AAGA,MAAA,SAAAgB,IAAA,CAAA;QAAAC,IAAA;AAAAC,QAAAA,KAAAA;AAAA,OAAA,EAAA;AAOE,QAAA,IAAAA,KAAA,EAAA;AACEZ,UAAAA,QAAA,CAAAU,IAAA,CAAAG,UAAA,GAAAA,UAAA,GAEIC,qBAAA,CAAAD,UAAA,EAAAD,KAAA,CAFJ,oCAAA,CAAA,CAAA;AAKD,SAAA;;AAED,QAAA,IAAA,CAAAD,IAAA,IAAA,CAAAP,KAAA,EAAA;;AAEC,SAAA;;;;;;AAOL;;;;AAMF,IAAA,OAAA,MAAA;MACE,IAAAH,QAAA,IAAAA,QAAA,CAAAc,MAAA;;KADF,CAAA;AAIF,GAzDA,CAAA,CAAA;AA0DF,CA9DA,CAAA;AAgEA;;;AACA,IAAAC,eAAA,GAAA,CAAA;EAAAC,MAAA;EAAAC,SAAA;EAAAC,OAAA;EAAAC,aAAA;EAAAC,YAAA;AAAAC,EAAAA,sBAAAA;AAAA,CAAA,KAAA,CAAA;AAAAC,EAAAA,OAAAA;AAAA,CAAA,KAAA;;AASI,IAAA,IAAAC,UAAA,GAAAC,WAAA,CAAAC,IAAA,CAAA,CAAA;uBAUEC,cAAA,CAAA9B,SAAA,IAAA;MAEE,IAAA;AAAA+B,QAAAA,GAAAA;AAAA,OAAA,GAAA/B,SAAA,CAAA;;AAMA,MAAA,IAAAM,YAAA,GAAA,OAAAgB,OAAA,KAAA,UAAA,GAAAA,OAAA,CAAAtB,SAAA,CAAA,GAAAsB,OAAA,CARF;;;;;;AAeI,QAAA,KAAA,IAAAS,IAAA,IAAA/B,SAAA,CAAAgC,SAAA,EAAA;;;AAGG,WAAA;AACF,SAAA;AACF,OAAA;;MAED,OAWGC,eAAA,CAAAC,SAAA,CAXH,CAAAnC,iBAAA,CAAAC,SAAA,EAAA;cAAA;iCAAA;iBAAA;oBAAA;sBAAA;AAOImC,QAAAA,aAAA,EAAAC,qBAAA,CAAApC,SAAA,CAAAqC,KAAA,CAPJ;qBAAA;oBAAA;;AAAA,OAAA,CAAA,CAAA,CAAA;KAtBF;AALE,MAAA,OAAArC,SAAA,CAAAQ,IAAA,KAAA,OAAA,iCAAA,IAGER,SAAA,CAAAQ,IAAA,KAAA,cAHF,CAAA;;;;;AAoDR;;;;"}