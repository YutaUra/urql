{"version":3,"file":"urql-exchange-execute.min.js","sources":["../src/execute.ts"],"sourcesContent":["import {\n  Source,\n  pipe,\n  share,\n  filter,\n  takeUntil,\n  mergeMap,\n  merge,\n  make,\n} from 'wonka';\n\nimport {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  GraphQLTypeResolver,\n  execute,\n  subscribe,\n  ExecutionArgs,\n  SubscriptionArgs,\n} from 'graphql';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  makeResult,\n  makeErrorResult,\n  mergeResultPatch,\n  Operation,\n  OperationResult,\n  getOperationName,\n} from '@urql/core';\n\nexport interface ExecuteExchangeArgs {\n  schema: GraphQLSchema;\n  rootValue?: any;\n  context?: ((op: Operation) => any) | any;\n  fieldResolver?: GraphQLFieldResolver<any, any>;\n  typeResolver?: GraphQLTypeResolver<any, any>;\n  subscribeFieldResolver?: GraphQLFieldResolver<any, any>;\n}\n\ntype ExecuteParams = ExecutionArgs | SubscriptionArgs;\n\nconst asyncIterator =\n  typeof Symbol !== 'undefined' ? Symbol.asyncIterator : null;\n\nconst makeExecuteSource = (\n  operation: Operation,\n  _args: ExecuteParams\n): Source<OperationResult> => {\n  return make<OperationResult>(observer => {\n    let iterator: AsyncIterator<ExecutionResult>;\n    let ended = false;\n\n    Promise.resolve()\n      .then(async () => ({ ..._args, contextValue: await _args.contextValue }))\n      .then(args => {\n        if (ended) return;\n        if (operation.kind === 'subscription') {\n          return subscribe(args) as any;\n        }\n        return execute(args) as any;\n      })\n      .then((result: ExecutionResult | AsyncIterable<ExecutionResult>) => {\n        if (ended || !result) {\n          return;\n        } else if (!asyncIterator || !result[asyncIterator]) {\n          observer.next(makeResult(operation, result as ExecutionResult));\n          return;\n        }\n        iterator = result[asyncIterator!]();\n        let prevResult: OperationResult | null = null;\n\n        function next({\n          done,\n          value,\n        }: {\n          done?: boolean;\n          value: ExecutionResult;\n        }) {\n          if (value) {\n            observer.next(\n              (prevResult = prevResult\n                ? mergeResultPatch(prevResult, value)\n                : makeResult(operation, value))\n            );\n          }\n\n          if (!done && !ended) {\n            return iterator.next().then(next);\n          }\n        }\n\n        return iterator.next().then(next);\n      })\n      .then(() => {\n        observer.complete();\n      })\n      .catch(error => {\n        observer.next(makeErrorResult(operation, error));\n        observer.complete();\n      });\n\n    return () => {\n      if (iterator && iterator.return) iterator.return();\n      ended = true;\n    };\n  });\n};\n\n/** Exchange for executing queries locally on a schema using graphql-js. */\nexport const executeExchange = ({\n  schema,\n  rootValue,\n  context,\n  fieldResolver,\n  typeResolver,\n  subscribeFieldResolver,\n}: ExecuteExchangeArgs): Exchange => ({ forward }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const executedOps$ = pipe(\n      sharedOps$,\n      filter((operation: Operation) => {\n        return (\n          operation.kind === 'query' ||\n          operation.kind === 'mutation' ||\n          operation.kind === 'subscription'\n        );\n      }),\n      mergeMap((operation: Operation) => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const contextValue =\n          typeof context === 'function' ? context(operation) : context;\n\n        // Filter undefined values from variables before calling execute()\n        // to support default values within directives.\n        const variableValues = Object.create(null);\n        if (operation.variables) {\n          for (const key in operation.variables) {\n            if (operation.variables[key] !== undefined) {\n              variableValues[key] = operation.variables[key];\n            }\n          }\n        }\n\n        return pipe(\n          makeExecuteSource(operation, {\n            schema,\n            document: operation.query,\n            rootValue,\n            contextValue,\n            variableValues,\n            operationName: getOperationName(operation.query),\n            fieldResolver,\n            typeResolver,\n            subscribeFieldResolver,\n          }),\n          takeUntil(teardown$)\n        );\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      sharedOps$,\n      filter(operation => operation.kind === 'teardown'),\n      forward\n    );\n\n    return merge([executedOps$, forwardedOps$]);\n  };\n};\n"],"names":["asyncIterator","require","Symbol","makeExecuteSource","typeResolver","subscribeFieldResolver","forward","key","sharedOps$","wonka","share","ops$","contextValue","operation","variables","_key","undefined","takeUntil","teardown$","_args","make","observer","ended","then","subscribe","args","execute","result","value","done","makeResult","error","next","core","makeErrorResult","iterator","return","operationName","getOperationName","query"],"mappings":"8EA2CAA,EAAAC,QAAAC,WAGAC,wBAKIH,EAAA,oBAAAE,OAAAA,OAAAF,cAAA,6BA4DJ,EAAAI,SAAAC,sBAAAC,gBAAAF,0DAqBQG,IAAA,IAAAC,EAAAC,EAAAC,MAAAC,qBAMA,IAAAC,gHAUK,GAAAC,EAAAC,UACF,IAAA,IAAAC,KAAAF,EAAAC,eACFE,IAAAH,EAAAC,UAAAC,iCAEDN,EAAAQ,UAAAC,EAAAT,KAjGDU,IAAAV,EAAAW,MAAAC,IAAA,MAECC,GAAA,EAPN,+CAQMV,mBAAAO,mBACEI,MAAAC,IACD,IAAAF,EACD,MAAAG,iBAAAC,EAAAA,OAEDF,UAAAC,qDAUCE,EAAA3B,KAAA4B,IAAAA,EAAAA,2BAOE,YAAAC,KACER,EAAAA,MAKDO,OAEDA,6FAlBFD,KAAAA,EAAAG,WAAAjB,EAAAc,0CAiCJI,IACEV,EAAAW,KAAAC,EAAAC,sCAtDJ,KAJFC,GAAAA,EAAAC,QAAAD,EAAAC,SAgEAd,GAAA,MA0CQnB,CAAAU,EAAA,UAOIwB,WAAAC,kDAPJD,cAAAJ,EAAAK,iBAAAzB,EAAA0B,mJAyBR/B"}