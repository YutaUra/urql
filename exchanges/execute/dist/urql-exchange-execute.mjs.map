{"version":3,"file":"urql-exchange-execute.mjs","sources":["../src/execute.ts"],"sourcesContent":["import {\n  Source,\n  pipe,\n  share,\n  filter,\n  takeUntil,\n  mergeMap,\n  merge,\n  make,\n} from 'wonka';\n\nimport {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  GraphQLTypeResolver,\n  execute,\n  subscribe,\n  ExecutionArgs,\n  SubscriptionArgs,\n} from 'graphql';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  makeResult,\n  makeErrorResult,\n  mergeResultPatch,\n  Operation,\n  OperationResult,\n  getOperationName,\n} from '@urql/core';\n\nexport interface ExecuteExchangeArgs {\n  schema: GraphQLSchema;\n  rootValue?: any;\n  context?: ((op: Operation) => any) | any;\n  fieldResolver?: GraphQLFieldResolver<any, any>;\n  typeResolver?: GraphQLTypeResolver<any, any>;\n  subscribeFieldResolver?: GraphQLFieldResolver<any, any>;\n}\n\ntype ExecuteParams = ExecutionArgs | SubscriptionArgs;\n\nconst asyncIterator =\n  typeof Symbol !== 'undefined' ? Symbol.asyncIterator : null;\n\nconst makeExecuteSource = (\n  operation: Operation,\n  _args: ExecuteParams\n): Source<OperationResult> => {\n  return make<OperationResult>(observer => {\n    let iterator: AsyncIterator<ExecutionResult>;\n    let ended = false;\n\n    Promise.resolve()\n      .then(async () => ({ ..._args, contextValue: await _args.contextValue }))\n      .then(args => {\n        if (ended) return;\n        if (operation.kind === 'subscription') {\n          return subscribe(args) as any;\n        }\n        return execute(args) as any;\n      })\n      .then((result: ExecutionResult | AsyncIterable<ExecutionResult>) => {\n        if (ended || !result) {\n          return;\n        } else if (!asyncIterator || !result[asyncIterator]) {\n          observer.next(makeResult(operation, result as ExecutionResult));\n          return;\n        }\n        iterator = result[asyncIterator!]();\n        let prevResult: OperationResult | null = null;\n\n        function next({\n          done,\n          value,\n        }: {\n          done?: boolean;\n          value: ExecutionResult;\n        }) {\n          if (value) {\n            observer.next(\n              (prevResult = prevResult\n                ? mergeResultPatch(prevResult, value)\n                : makeResult(operation, value))\n            );\n          }\n\n          if (!done && !ended) {\n            return iterator.next().then(next);\n          }\n        }\n\n        return iterator.next().then(next);\n      })\n      .then(() => {\n        observer.complete();\n      })\n      .catch(error => {\n        observer.next(makeErrorResult(operation, error));\n        observer.complete();\n      });\n\n    return () => {\n      if (iterator && iterator.return) iterator.return();\n      ended = true;\n    };\n  });\n};\n\n/** Exchange for executing queries locally on a schema using graphql-js. */\nexport const executeExchange = ({\n  schema,\n  rootValue,\n  context,\n  fieldResolver,\n  typeResolver,\n  subscribeFieldResolver,\n}: ExecuteExchangeArgs): Exchange => ({ forward }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const executedOps$ = pipe(\n      sharedOps$,\n      filter((operation: Operation) => {\n        return (\n          operation.kind === 'query' ||\n          operation.kind === 'mutation' ||\n          operation.kind === 'subscription'\n        );\n      }),\n      mergeMap((operation: Operation) => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const contextValue =\n          typeof context === 'function' ? context(operation) : context;\n\n        // Filter undefined values from variables before calling execute()\n        // to support default values within directives.\n        const variableValues = Object.create(null);\n        if (operation.variables) {\n          for (const key in operation.variables) {\n            if (operation.variables[key] !== undefined) {\n              variableValues[key] = operation.variables[key];\n            }\n          }\n        }\n\n        return pipe(\n          makeExecuteSource(operation, {\n            schema,\n            document: operation.query,\n            rootValue,\n            contextValue,\n            variableValues,\n            operationName: getOperationName(operation.query),\n            fieldResolver,\n            typeResolver,\n            subscribeFieldResolver,\n          }),\n          takeUntil(teardown$)\n        );\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      sharedOps$,\n      filter(operation => operation.kind === 'teardown'),\n      forward\n    );\n\n    return merge([executedOps$, forwardedOps$]);\n  };\n};\n"],"names":["executeExchange","schema","rootValue","context","fieldResolver","typeResolver","subscribeFieldResolver","ops$","sharedOps$","operation","key","filter","op","kind","undefined","_key","make","iterator","contextValue","then","args","subscribe","execute","result","ended","observer","done","value","next","prevResult","mergeResultPatch","makeResult","return","query","getOperationName","operationName"],"mappings":";;;;;;;;wBA+GAA,WAAAC,cAAAC,YAAAC,kBAAAC,iBAAAC,+BAAAC,kBAAAC;;EASI,IAAAC,OAAAC;cAYIC,KAAAA;IAAA,IAAAD,IAAAE,GAAAC,KAAA,eAAAA,EAAAC,QAAAD,EAAAF,QAAAA,GAAAC,CAAAH;;;;;iBAaEM,MAAAJ,YAAAK;;;;;;MA/FRC,IAAAA;MACE,IAAAC,KAAA;;;8BAIGC;WAAAC,MAAAC;;;;;iBAGCC,EAAAD;;;UAGAE,MAAAA;QAEDH,UAAAI;UACCC;;UAAAC;;;;QAMAR,QAAA;mDAGAS,GAAAC,OAAAD;UAAA,IAAAC;YAOEF,EAAAG,KAAAC,IAAAA,IAAAC,EAAAD,GAAAF,KAAAI,EAAAtB,GAAAkB;;;mBAQAV,SAAAE,KAAAS;;;;;;;;;;iBAeNX,EAAAe;UAAAf,EAAAe;;QACER,KAAA;;;MAgDEvB;gBAAAQ,EAAAwB;;;;qBAAAC,EAAAzB,EAAAwB;MAOIE;;;;MAPJxB,GAAAF,+EAAAE;;;;;"}